# 통합 열거형 및 열거형 멤버 타입

계산되지 않은 상수 열거형 멤버의 특수 하위 집합이 있습니다. 리터럴 열거형 멤버입니다.<br/>
리터럴 열거형 멤버는 초기화된 값이 없거나 다음 값으로 초기화 된 값이 있는 상수 열거형 멤버입니다.

- 문자열 리터럴 (예: `"foo"`, `"bar"`, `"baz"`)
- 숫자 리터럴 (예: `1`, `100`)
- 숫자 리터럴에 적용되는 단항 마이너스 (예: `-1`, `-100`)

열거형의 모든 멤버가 리터럴 열거형 값을 가질 때 일부 특수한 의미가 있습니다.

첫 번째는 열거형 멤버도 타입이 된다는 것입니다. 예를 들어 특정 멤버는 열거형 멤버의 값만 가질 수 있습니다.

```ts
enum ShapeKind {
  Circle,
  Square,
}

interface Circle {
  kind: ShapeKind.Circle;
  radius: number;
}

interface Square {
  kind: ShapeKind.Square;
  sideLength: number;
}

let c: Circle {
  kind: ShapeKind.Sqaure,
  // ❌
  radius: 100,
}
```

또 다른 변화는 열거 타입 자체가 각 열거형 멤버의 합집합(union)이 된다는 것입니다.<br/>
결합 타입(union types)에 대해 아직 배우지 않았지만, 알아 두어야 할 것은 조합 열거형을 사용하는 타입 시스템이 열거형 자체에 존재하는 정확한 값들을 알고 있다는 사실을 활용할 수 있다는 것입니다.<br/>
이 때문에 TypeScript는 값을 잘못 비교하는 바보같은 버그를 잡을 수 있습니다.

```ts
enum E {
  Foo,
  Bar,
}

function f(x: E) {
  if(x !== E.foo || x !== E.Bar) {
    //              ~~~~~~~~~~~ ❌
    // 오류, 연산자 '!=='는 "E.Foo' 및 'E.Bar' 타입에 적용할 수 없습니다;
  }
}
```

이 예제에서, 먼저 `x`가 `E.Foo`가 아닌지 검사했습니다<br/>
이 검사를 성공하면 || 가 실행되지 않고 'if' 내부가 실행됩니다.<br/>
하지만 검사를 성공하지 못하면 `x`는 오직 `E.Foo`만 될 수 있습니다. 따라서 `E.Bar`와 동일한지 확인하는 것은 의미가 없습니다.
