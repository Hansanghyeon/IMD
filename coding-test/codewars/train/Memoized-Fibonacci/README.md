# Memoized Fibonacci

## 문제 상황

재귀를 설명하는데는 전통적으로 피보나치 시퀸스로 설명을합니다.

```js
function fibonacci(n) {
  if(n === 0 || n === 1)
    return n;
  return fibonacci(n-1) + fibonacci(n-2);
}
```

이 알고리즘은 교육적 목적을 잘 제공하지만 재귀 때문에 뿐만 아니라 피보나치 함수를 두 번 호출하고 오른쪽 재귀 분기(즉)는 왼쪽 지점에서 이미 계산 한 모든 피보나치 수를 다시 계산하기 때문에 엄청나게 비효율적입니다.
`fibonacci(n-1) + fibonacci(n-2)` 

이 알고리즘은 매우 비효율적이므로 50을 초과하는 피보나치 수를 계산하는 시간이 너무 많습니다.

우리는 메모리 솔루션을 구현하려합니다. 이것은 트리 재귀알고리즘을 계속 사용하면서도 대답을 매우 빠르게 얻을 추 있도록 충분히 최적화 된 상태를 유지할 수 있기 때문에 멋질것입니다.

메모리 화 된 버전의 요점은 계산할 때 피보나치 수를 저장할 캐시 데이터 구조(대부분 연관 배열)를 유지하는 것입니다. 피보나치수를 계산할 때 먼저 캐시에서 찾아보고, 없는 경우 계싼하여 캐시에 넣습니다. 그렇지 않으면 캐시 된 숫자를 반환합니다.

메로리 화 된 데이터 구조를 사용하면 트리 재귀의 결함을 피할 수 있는 함수를 재귀 피보나치 함수로 리팩토링합니다.

---

## 메모이제이션

**메모이제이션**이란 프로그래밍을 할 때 반복되는 결과를 메모리에 저장해서 다음에 같은 결과가 나올 때 빨리 실행하는 코딩 기법

클로저를 상요하여 기존값을 메모리에 저장하고 저장된 값을 활용하는 방법으로 같은 계산을 한번더 하지않아되도록 솔루션을 내면된다.