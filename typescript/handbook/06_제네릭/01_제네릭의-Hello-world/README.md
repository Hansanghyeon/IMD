# 제네릭의 Hello World

우선 제네릭의 "Hello World"즉 identity 함수를 만들어 봅시다.<br/>
이 identity 함수는 전달된 것을 그대로 반환하는 함수입니다.<br/>
이는 `echo` 명령과 비슷한 방식으로 생각하면 됩니다.

제네릭이 없다면 identity 함수에 특정 타입을 부여해야 합니다.

```ts
function identity(arg: number): number {
  return arg;
}
```

또는 `any` 타입을 사용하여 identity 함수를 만들 수 있습니다.

```ts
function identity(arg: any): any {
  return arg;
}
```

`any`를 사용하는 것은 분명히 함수가 `arg`에 대한 모든 타입을 전달 받을 수 있게되지만 실제로 함수가 반환할 때 그 타입이 무엇이었는지에 대한 정보를 잃어버립니다.<br/>
만약 숫자를 인수로 전달하면 어떤 타입이든 반환할 수 있다는 것을 알 수 있습니다.

대신 어떤 타입이 반환될 것인지를 나타내는 데 사용할 수 있는 방식으로 인수 타입을 정하는 방법이 필요합니다.<br/>
여기서 값이 아닌 타입을 처리하는 특별한 변수인 타입 변수를 사용할 것입니다.

```ts
funciton identity<T>(arg: T): T {
  return arg;
}
```

identity 함수에 타입 변수 `T`를 추가했습니다.<br/>
이 `T`는 함수 사용자가 제공한 타입(예: `number`)를 캡처하여 나중에 해당 정도를 사용할 수 있도록 합니다.<br/>
또한 `T`를 다시 반환 타입으로 사용합니다.<br/>
자세히 보면 인수와 반환 타입에 동일한 타입이 사용되는 것을 볼 수 있습니다.<br/>
이를 통해 함수의 안과 밖에서 타입에 대한 정보를 넘길 수 있습니다.

이러한 모습의 `identity`함수는 다양한 타입을 처리할 수 있기 때문에 일반적이라고 할 수 있습니다.<br/>
`any`를 사용하는 것과 달리 인수와 반환 타입에 숫자를 사용하는 처음의 `identity`함수와 동일합니다.(즉 어떠한 정보도 잃어버리지 않습니다.)

제네릭 `identity` 함수를 만들 후 두 가지 방법 중 하나로 호출할 수 있습니다.<br/>
첫번째 방법은 타입 인수를 포함한 모든 인수를 함수에 전달하는 것입니다.

```ts
let output = identity<string>("myString");  // 반환 타입은 'string'입니다.
```

여기서는 함수 호출에 대한 인수 중 하나인 `T`를 `string`으로 명시적으로 정했으며 인수에는 `()`를 사용하는 것과 달리 `<>`를 사용했습니다.

두번째 방법은 더 일반적인 방법이기도 합니다.<br/>
여기서는 타입 인수 추론를 사용합니다.<br/>
즉 함수에 전달하는 인수 타입에 따라 컴파일러가 자동으로 `T` 값을 설정합니다.

```ts
let output = identity("myString");  // 반환 타입은 "string"입니다.
```

꺾쇠 괄호(`<>`) 안에 명시적으로 타입을 전달할 필요가 없습니다.<br/>
컴파일러는 그저 `"myString"`의 값을 보고 `T` 를 그 타입으로 설정합니다.<br/>
타입 인수 추론은 코드를 더 짧고 가독성 있게 유지하는 유용한 도구가 될 수 있지만 보다 복잡한 예제에서는 컴파일러가 타입을 추론하지 못하면 앞의 예제에서 했던 것 처럼 타입 인수를 명시적으로 전달해야 할 수도 있습니다.